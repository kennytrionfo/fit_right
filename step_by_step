Step by step instructions on how to build fit_right app in ruby on rails. 

Create a new rails app:
	skipping test unit and using Postgress DB in the installation:
	rails new fit_right --skip-test-unit -d postgresql
	should see rails create a bunch of files & directories for you and then bundle install for you too. 

Start repo:
	Initialize a repository on your machine:  
		git init
		git add .
		git commit -m "first commit"
	Create a remote repo on github and sync them:
		Go create the repo on github
		git remote add origin https://github.com/kennytrionfo/fit_right.git
		git push -u origin master

Start documentation: 
	Open app in text editor, 
	Edit readme file if u like, 
	Start step by step instructions file if you like. 

System check: 
	Check ur Rubies, versions and gems etc. i.e. rvm, ruby, rails, bundle, gems etc. 
	rvm list
	rvm gemset
	ruby -v
	rails -v

Install gems: 
	In Gemfile:
	Better Errors, factory girl, sprockets? 
	Minitest: 
	group :test, :development do
  	gem "minitest-rails"
	end
	Check for the minitest generator in console with: 
	rails generate
	Install the gem with this from the console:
	rails g minitest:install
	Should see a test folder now in ur app in text editor. 

PUT TESTING IN HERE ALONG THE WAY!
	
Create todo_list model with controllers, views and test files: 
	rails g scaffold todo_list title:string description:text
	then

rake db:migrate

Confirm in localhost:3000/todo_list

Change root to point to the todo_lists controller and the index action: 
	In routes.rb file: 
	root "todo_lists#index"
	Check localhost:3000 in browser. Should show all the lists without need to go to /todo_lists

Generate a model for our todo items with a content row/attribute that's a string and that references the todo_list: 
	With: 
	rails g model todo_item content:string todo_list:references 

rake db:migrate

Do your associations for you models: 
	Tell the todo_list model that it has many todo_items: 
	In the todo_list.rb file: 
	has_many :todo_items

	Tell the todo_item model that it belongs to todo_lists with: 
	belongs_to :todo_list

Create some nested routes for our todo_items: 
	In routes.rb file, make todo_lists resources a block with todo_items resources inside:  
	resources :todo_lists do
		resources :todo_items
	end

Look at the routes this created: 
	With: 
	rake routes

Generate a controller for your todo_item: 
	In the console with: 
	rails g controller todo_items

Give yourself the ability to create new todo lists with new todo items: 
	In todo_items_controller.rb, create a create method that creates a new todo_list variable/instance by setting it to a new TodoList that you find by the todo_list_id key. 
	Then create a method that creates a new todo item by .. 
	with two private methods, one to set the todo list and one to create todo item params like: 
	
	before_action :set_todo_list

	def create
		@todo_item = @todo_list.todo_item.create(todo_item_params)
		redirect_to @todo_list 
	end


	private

	def set_todo_list 
		@todo_list = TodoList.find(params[:todo_list_id])
	end

	def todo_item_params
		params[:todo_item].permit(:content)
	end

Now create the form to actually create a new todo list: 
	Create two partials (new files) in views/todo_items:
	1 _form.html.erb 
	<%= form_for([@todo_list, @todo_list.todo_items.build]) do |f| %>
	<%= f.text_field :content, placeholder: "New Todo" %>
	<%= f.submit %>
	<%= end %>

	2 _todo_item.html.erb
	<p> <%= todo_item.content %></p>

Show the todo form and the todo list items under the todo list show page:
	Create a div that renders the todo list from the _todo_items.html.erb file. Under the description: 
	<div id="todo_items_wrapper">
		<%= render @todo_list.todo_items %>
	</div>
	Add another div inside of that div that renders the todo item's form: 
	<div id="form">
		<%= render "todo_items/form" %>
	</div>
	Test the show page that it shows and that you can make new todo items in a list. 

Add a delete button for the items: 
	Back in _todo_item.html.erb: 
	<%= link_to "Delete", todo_list_todo_item_path(@todo_list, todo_item.id), method: :delete, data: {confirm: "Are you sure?"} %>

Make it so that the app can take a delete request for an item and route it to the right method: 
	In todo items controller:
	def destroy
		@todo_item = @todo_list.todo_items.find(params[:id])
		if @todo_item.destroy
			flash[:success] = "Todo List item was deleted"
		else
			flash[:error] = "Todo List item could not be deleted dude."	
		end
		redirect_to @todo_list	
	end
	Check it in browser. 

Create the ability to mark an item as complete: 
	Add a migration to add a completed at datetime to the todo_items table: 
	In console: 
	rails g migration add_completed_at_to_todo_items completed_at:datetime
	rake db:migrate

	Add a route to give users the ability to mark an item as complete: 
	In config/routes.rb: 
	Make the todo_items resources a block and add patch :complete. Should look like:
	resources :todo_items do
      member do
        patch :complete
      end
    end
    rake routes to see it at the top. 

    In views/todo_items/_todo_item.html.erb add:
    <%= link_to "Mark as Complete", complete_todo_list_todo_item_path(@todo_list, todo_item.id), method: :patch %>
    Test in browswer. 

    Now add the complete action in the todo_items controller: 
    Create a private method: 
    def set_todo_item
		@todo_item = @todo_list.todo_items.find(params[:id])		
	end
	We can also now remove this line from the destroy action above now that it's a private method. 
	Now create a before action: 
	before_action :set_todo_item, except: [:create]

	Create a create action: 
	def complete
		@todo_item.update_attribute(:completed_at, Time.now)
		redirect_to @todo_list, notice: "Todo item completed dude"
	end
	Test in browswer. Just a flash message will show is all at this point. It is marked as complete but nothing changes. 

	Next clean up and add to _todo_item.html.erb: 
	Replace what's there with: 
	<div class="row clearfix">
		<% if todo_item.completed? %>
			<div class="complete">
				<%= link_to "Mark as Complete", complete_todo_list_todo_item_path(@todo_list, todo_item.id), method: :patch %>
			</div>
			<div class="todo_item">
				<p style="opacity: 0.4;"><strike><%= todo_item.content %></strike></p>
			</div>
			<div class="trash">
				<%= link_to "Delete", todo_list_todo_item_path(@todo_list, todo_item.id), method: :delete, data: { confirm: "Are you sure?" } %>
			</div>
		<% else %>
			<div class="complete">
				<%= link_to "Mark as Complete", complete_todo_list_todo_item_path(@todo_list, todo_item.id), method: :patch %>
			</div>
			<div class="todo_item">
				<p><%= todo_item.content %></p>
			</div>
			<div class="trash">
				<%= link_to "Delete", todo_list_todo_item_path(@todo_list, todo_item.id), method: :delete, data: { confirm: "Are you sure?" } %>
			</div>
		<% end %>
	</div>

	We can't use the todo_item.completed?, we have to define what it is so in TodoItem Model: 
	def completed? # If it's completed, the completed_at field should not be blank. 
		!completed_at.blank?  	
  	end
  	Test in browser.






Stopped vid at:
22:00







